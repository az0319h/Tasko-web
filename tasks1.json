{
  "project_name": "일정관리 페이지 수정",
  "description": "일정관리 페이지에서 task 상태 아이콘 표시, 카테고리별 색상 적용, 관리자용 모든 사용자 일정 조회 옵션 추가, 일정 자동 배정 로직 개선",
  "test_environment": {
    "method": "Restore to new project",
    "description": "원본 프로젝트를 새 프로젝트로 복사하여 테스트 환경 구성. 테스트 완료 후 원본 DB에 마이그레이션 파일 적용.",
    "backup_method": "Point-in-Time Recovery (PITR)",
    "notes": "모든 백업은 Supabase Point-in-Time Recovery 사용. 테스트 환경에서 검증 후 원본 DB에 적용."
  },
  "migration_file_structure": {
    "location": "supabase/migrations/schedule_end",
    "naming_convention": "YYYYMMDDHHMMSS_migration_name.sql",
    "description": "일정 관련 DB 변경사항은 마이그레이션 파일로 작성. 테스트 환경에서 검증 후 원본 DB에 적용."
  },
  "current_db_status": {
    "task_schedules_table": {
      "exists": true,
      "has_trigger": true,
      "trigger_creates_all_day": true
    },
    "tasks_table": {
      "has_task_category": true,
      "has_task_status": true
    }
  },
  "tasks": [
    {
      "id": 1,
      "title": "Task 상태 아이콘 표시 추가",
      "description": "일정관리 페이지에서 task가 지시사항만 나오는 것을 상태 아이콘과 함께 표시하도록 수정. 대시보드의 TaskStatusBadge와 동일한 아이콘 및 색상 사용",
      "status": "completed",
      "sub_tasks": [
        {
          "id": "1-1",
          "title": "src/components/schedule/task-calendar.tsx의 handleEventContent 함수 수정",
          "description": "handleEventContent 함수에서 지시사항과 함께 task 상태 아이콘 표시 (텍스트 없이 아이콘만). TaskStatusBadge와 동일한 아이콘 및 색상 사용",
          "status": "completed",
          "files": ["src/components/schedule/task-calendar.tsx"],
          "notes": "TaskStatusBadge 컴포넌트를 참고하여 아이콘만 표시하도록 수정. handleEventContent에서 task.task_status를 사용하여 적절한 아이콘 렌더링. 아이콘은 지시사항 옆에 작게 표시. 색상: ASSIGNED(기본색), IN_PROGRESS(text-yellow-500), WAITING_CONFIRM(text-red-500), APPROVED(text-green-500), REJECTED(text-red-500, opacity-50)"
        },
        {
          "id": "1-2",
          "title": "상태 아이콘 유틸 함수 추가",
          "description": "상태별 아이콘과 색상을 반환하는 함수 생성 (TaskStatusBadge와 동일한 스타일)",
          "status": "completed",
          "files": ["src/utils/schedule.ts"],
          "notes": "TaskStatusBadge에서 사용하는 아이콘과 색상을 참고하여 유틸 함수 생성. ASSIGNED: FileText (기본색), IN_PROGRESS: Loader2 (text-yellow-500), WAITING_CONFIRM: Clock (text-red-500), APPROVED: CheckCircle2 (text-green-500), REJECTED: XCircle (text-red-500, opacity-50)"
        }
      ]
    },
    {
      "id": 2,
      "title": "Task 카테고리별 색상 적용",
      "description": "일정관리 페이지에서 task 색상을 상태별이 아닌 카테고리별로 변경",
      "status": "completed",
      "sub_tasks": [
        {
          "id": "2-1",
          "title": "src/utils/schedule.ts의 getStatusColor 함수를 getCategoryColor로 변경",
          "description": "getStatusColor 함수를 getCategoryColor로 변경하고 카테고리별 색상 매핑 정의",
          "status": "completed",
          "files": ["src/utils/schedule.ts"],
          "notes": "카테고리별 색상: REVIEW(검토): 파란색 (#3b82f6), REVISION(수정): 보라색 (#a855f7), CONTRACT(계약): 초록색 (#22c55e), SPECIFICATION(명세서): 주황색 (#f97316), APPLICATION(출원): 청록색 (#14b8a6)"
        },
        {
          "id": "2-2",
          "title": "convertToFullCalendarEvents 함수에서 카테고리 색상 사용",
          "description": "convertToFullCalendarEvents 함수에서 task.task_status 대신 task.task_category를 사용하여 색상 결정",
          "status": "completed",
          "files": ["src/utils/schedule.ts"],
          "notes": "getStatusColor(status) 호출을 getCategoryColor(category)로 변경. task.task_category를 사용하여 색상 결정."
        }
      ]
    },
    {
      "id": 3,
      "title": "관리자용 모든 사용자 일정 조회 옵션 추가",
      "description": "관리자가 일정관리 페이지에서 '내 일정'과 '전체 사용자 일정'을 선택할 수 있도록 드롭다운 수정. '전체 사용자 일정' 선택 시 각 사용자마다 별도의 캘린더를 표시하여 스크롤로 확인 가능하도록 구현",
      "status": "completed",
      "sub_tasks": [
        {
          "id": "3-1",
          "title": "src/pages/schedule-page.tsx 드롭다운 및 UI 구조 수정",
          "description": "사용자 선택 드롭다운에 '내 일정'과 '전체 사용자 일정' 옵션만 제공. '전체 사용자 일정' 선택 시 각 사용자마다 별도의 캘린더 컴포넌트 렌더링",
          "status": "completed",
          "files": ["src/pages/schedule-page.tsx"],
          "notes": "기존 개별 사용자 선택 제거. '내 일정' (undefined)과 '전체 사용자 일정' ('all') 옵션만 제공. '전체 사용자 일정' 선택 시 users 배열을 순회하며 각 사용자마다 '사용자명 + TaskCalendar' 컴포넌트를 세로로 배치하여 스크롤로 확인 가능하도록 구현."
        },
        {
          "id": "3-2",
          "title": "src/api/schedule.ts의 getTaskSchedules 함수 수정",
          "description": "userId가 특정 값일 때 해당 사용자의 일정만 조회하도록 유지 (각 사용자별 캘린더를 위해)",
          "status": "completed",
          "files": ["src/api/schedule.ts"],
          "notes": "기존 로직 유지. 각 사용자별로 일정을 조회하기 위해 userId를 전달받아 해당 사용자의 일정만 조회. '전체 사용자 일정' 모드에서는 각 사용자마다 별도로 API 호출."
        },
        {
          "id": "3-3",
          "title": "src/components/schedule/task-calendar.tsx 수정",
          "description": "selectedUserId가 특정 사용자 ID일 때 해당 사용자의 일정만 표시하도록 유지",
          "status": "completed",
          "files": ["src/components/schedule/task-calendar.tsx"],
          "notes": "기존 로직 유지. 각 사용자별 캘린더를 렌더링하기 위해 selectedUserId를 prop으로 받아 해당 사용자의 일정만 표시."
        },
        {
          "id": "3-4",
          "title": "src/hooks/queries/use-schedules.ts 쿼리 키 수정",
          "description": "각 사용자별로 별도의 쿼리 키 사용",
          "status": "completed",
          "files": ["src/hooks/queries/use-schedules.ts"],
          "notes": "각 사용자별로 별도의 쿼리 키를 사용하여 캐싱 및 무효화 처리. '전체 사용자 일정' 모드에서는 각 사용자마다 별도의 쿼리 실행."
        }
      ]
    },
    {
      "id": 4,
      "title": "일정 자동 배정 로직 개선 및 승인 시 종일 처리",
      "description": "일정 생성 시 마감일에 종일로 배정하는 대신 오전 9시~오후 7시 사이 가장 빠른 빈 시간에 1시간 배정. Task 승인 시 일정을 삭제하는 대신 종일로 변경",
      "status": "completed",
      "sub_tasks": [
        {
          "id": "4-1",
          "title": "일정 자동 배정 트리거 함수 수정 마이그레이션 파일 작성",
          "description": "create_task_schedule() 함수를 수정하여 오전 9시~오후 7시 사이 가장 빠른 빈 시간에 1시간 배정하도록 변경",
          "status": "completed",
          "migration_file": "supabase/migrations/schedule_end/20260129000001_update_task_schedule_auto_assign.sql",
          "sql_preview": "CREATE OR REPLACE FUNCTION public.create_task_schedule() RETURNS TRIGGER AS $$ DECLARE target_date DATE; start_hour INT := 9; end_hour INT := 19; current_hour INT; found_slot BOOLEAN := false; schedule_start TIMESTAMPTZ; schedule_end TIMESTAMPTZ; BEGIN IF NEW.assignee_id IS NOT NULL AND NEW.due_date IS NOT NULL THEN target_date := DATE_TRUNC('day', NEW.due_date)::DATE; -- 마감일부터 시작하여 최대 30일까지 검색 FOR day_offset IN 0..30 LOOP current_hour := start_hour; -- 오전 9시부터 오후 7시까지 1시간 단위로 검색 WHILE current_hour < end_hour LOOP schedule_start := (target_date + day_offset * INTERVAL '1 day' + current_hour * INTERVAL '1 hour')::TIMESTAMPTZ; schedule_end := schedule_start + INTERVAL '1 hour'; -- 해당 시간대에 기존 일정이 있는지 확인 (같은 담당자의 일정) IF NOT EXISTS (SELECT 1 FROM public.task_schedules ts INNER JOIN public.tasks t ON ts.task_id = t.id WHERE t.assignee_id = NEW.assignee_id AND ts.start_time < schedule_end AND ts.end_time > schedule_start) THEN found_slot := true; EXIT; END IF; current_hour := current_hour + 1; END LOOP; IF found_slot THEN EXIT; END IF; END LOOP; IF found_slot THEN INSERT INTO public.task_schedules (task_id, start_time, end_time, is_all_day) VALUES (NEW.id, schedule_start, schedule_end, false); END IF; END IF; RETURN NEW; EXCEPTION WHEN OTHERS THEN RAISE WARNING 'Failed to create task schedule: %', SQLERRM; RETURN NEW; END; $$ LANGUAGE plpgsql SECURITY DEFINER;",
          "notes": "⚠️ 중요: 기존 트리거 함수를 완전히 교체. 마감일부터 시작하여 최대 30일까지 검색. 오전 9시~오후 7시 사이에서 1시간 단위로 빈 시간 검색. 같은 담당자의 기존 일정과 겹치지 않는 시간에 배정. is_all_day = false로 설정. 테스트 환경에서 먼저 검증 필요."
        },
        {
          "id": "4-2",
          "title": "Task 승인 시 일정을 종일로 변경하는 트리거 함수 수정",
          "description": "delete_schedule_on_approved() 함수를 수정하여 일정을 삭제하는 대신 종일로 변경하도록 수정",
          "status": "completed",
          "migration_file": "supabase/migrations/schedule_end/20260129000002_`update_schedule_on_approved_to_all_day.sql",
          "sql_preview": "CREATE OR REPLACE FUNCTION public.update_schedule_on_approved() RETURNS TRIGGER AS $$ DECLARE due_date_val DATE; BEGIN -- Task 상태가 APPROVED로 변경되었을 때 일정을 종일로 변경 IF NEW.task_status = 'APPROVED' AND (OLD.task_status IS NULL OR OLD.task_status != 'APPROVED') THEN -- 해당 Task의 일정이 있는지 확인하고 종일로 변경 IF EXISTS (SELECT 1 FROM public.task_schedules WHERE task_id = NEW.id) THEN due_date_val := DATE_TRUNC('day', NEW.due_date)::DATE; UPDATE public.task_schedules SET start_time = due_date_val::TIMESTAMPTZ, end_time = (due_date_val + INTERVAL '1 day' - INTERVAL '1 second')::TIMESTAMPTZ, is_all_day = true, updated_at = NOW() WHERE task_id = NEW.id; END IF; END IF; RETURN NEW; EXCEPTION WHEN OTHERS THEN RAISE WARNING 'Failed to update task schedule on approved: %', SQLERRM; RETURN NEW; END; $$ LANGUAGE plpgsql SECURITY DEFINER; DROP TRIGGER IF EXISTS trigger_delete_schedule_on_approved ON public.tasks; CREATE TRIGGER trigger_update_schedule_on_approved AFTER UPDATE ON public.tasks FOR EACH ROW EXECUTE FUNCTION public.update_schedule_on_approved();",
          "notes": "⚠️ 중요: 기존 delete_schedule_on_approved 트리거를 제거하고 새로운 update_schedule_on_approved 트리거로 교체. Task 승인 시 일정을 삭제하는 대신 마감일에 종일로 변경. 마감일이 없으면 기존 일정의 날짜를 기준으로 종일로 변경."
        },
        {
          "id": "4-3",
          "title": "승인된 Task 일정 표시 로직 수정",
          "description": "convertToFullCalendarEvents 함수에서 승인된 Task도 표시하도록 수정",
          "status": "completed",
          "files": ["src/utils/schedule.ts"],
          "notes": "기존에 APPROVED 상태를 필터링하던 로직 제거. 승인된 Task도 일정에 표시되도록 수정. 승인된 Task는 종일로 표시됨."
        },
        {
          "id": "4-4",
          "title": "일정 자동 배정 로직 검증",
          "description": "새로운 일정 자동 배정 로직이 정상 동작하는지 테스트",
          "status": "completed",
          "test_guide": "SCHEDULE_AUTO_ASSIGN_TEST_GUIDE.md 파일 참조"
          "test_scenarios": [
            "마감일 오전 9시에 빈 시간이 있는 경우: 해당 시간에 배정",
            "마감일 오전 9시~오후 7시 사이에 빈 시간이 없는 경우: 다음 날 오전 9시부터 검색",
            "여러 날에 걸쳐 빈 시간이 없는 경우: 최대 30일까지 검색",
            "같은 담당자에게 여러 task가 동시에 생성되는 경우: 각각 다른 시간에 배정",
            "Task 승인 시 일정이 종일로 변경되는지 확인",
            "승인된 Task가 일정에 표시되는지 확인"
          ],
          "notes": "테스트 환경에서 다양한 시나리오로 검증. 동시성 문제 확인 필요."
        }
      ]
    },
    {
      "id": 5,
      "title": "통합 테스트 및 검증",
      "description": "모든 변경사항을 통합하여 테스트 및 검증",
      "status": "completed",
      "sub_tasks": [
        {
          "id": "5-1",
          "title": "일정관리 페이지 UI 테스트",
          "description": "상태 아이콘 표시, 카테고리별 색상, 사용자 선택 드롭다운 동작 확인",
          "status": "completed",
          "test_checklist": "SCHEDULE_UI_TEST_CHECKLIST.md 파일 참조"
          "test_scenarios": [
            "상태 아이콘이 지시사항과 함께 표시되는지 확인 (TaskStatusBadge와 동일한 아이콘 및 색상)",
            "카테고리별 색상이 올바르게 적용되는지 확인 (REVIEW: 파란색, REVISION: 보라색 등)",
            "관리자가 '내 일정' 선택 시 자신의 일정만 표시되는지 확인",
            "관리자가 '전체 사용자 일정' 선택 시 각 사용자마다 별도의 캘린더가 표시되는지 확인",
            "각 사용자 캘린더가 스크롤로 확인 가능한지 확인",
            "승인된 Task가 종일로 표시되는지 확인"
          ]
        },
        {
          "id": "5-2",
          "title": "일정 자동 배정 기능 테스트",
          "description": "새로운 일정 자동 배정 로직이 정상 동작하는지 확인",
          "status": "completed",
          "test_guide": "SCHEDULE_AUTO_ASSIGN_FUNCTIONAL_TEST.md 파일 참조"
          "test_scenarios": [
            "Task 생성 시 마감일 오전 9시~오후 7시 사이 가장 빠른 빈 시간에 배정되는지 확인",
            "해당 날짜에 빈 시간이 없을 때 다음 날로 이동하여 배정되는지 확인",
            "배정된 일정이 is_all_day = false이고 정확히 1시간인지 확인"
          ]
        },
        {
          "id": "5-3",
          "title": "TypeScript 컴파일 에러 확인",
          "description": "전체 프로젝트 TypeScript 컴파일 에러 확인 및 수정",
          "status": "completed",
          "command": "npm run build 또는 tsc --noEmit",
          "notes": "모든 변경사항 적용 후 TypeScript 컴파일 에러 확인 및 수정"
        }
      ]
    }
  ],
  "important_notes": [
    "모든 데이터베이스 변경 작업은 마이그레이션 파일로 작성하여 버전 관리",
    "테스트는 'Restore to new project'로 복사한 새 프로젝트에서 진행",
    "모든 백업은 Point-in-Time Recovery (PITR) 사용",
    "테스트 환경에서 모든 마이그레이션 파일 검증 완료 후 원본 DB에 적용",
    "코드 수정 전에 현재 코드 구조를 충분히 파악하고 진행",
    "일정 자동 배정 트리거 함수 수정 시 기존 로직과의 호환성 확인 필요",
    "카테고리별 색상은 사용자 피드백에 따라 조정 가능",
    "모든 사용자 일정 조회 시 성능 고려 (필요시 페이지네이션 또는 가상화 적용)"
  ],
  "db_verification_queries": {
    "check_task_schedules_auto_assign": "SELECT ts.id, ts.start_time, ts.end_time, ts.is_all_day, t.title, t.task_category, t.due_date FROM task_schedules ts INNER JOIN tasks t ON ts.task_id = t.id WHERE t.created_at > NOW() - INTERVAL '1 day' ORDER BY ts.start_time;",
    "check_category_colors": "SELECT DISTINCT task_category FROM tasks;",
    "check_schedule_time_range": "SELECT COUNT(*) as count, DATE_TRUNC('hour', start_time) as hour FROM task_schedules WHERE is_all_day = false GROUP BY DATE_TRUNC('hour', start_time) ORDER BY hour;"
  }
}
